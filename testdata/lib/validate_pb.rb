# Code generated by protoc-gen-rbi. DO NOT EDIT.
# source: validate.proto
# typed: strict

module 
end


module PbHelper
  extend T::Sig

  sig {
    params(value: T.untyped, defaultValue: T.untyped).returns(T.untyped)
  }
  def self.withDefault(value, defaultValue)
    value.nil? ? defaultValue : value
  end

  sig {
    params(value: T.untyped, blk: T.proc.params(v: T.untyped).returns(T.untyped)).returns(T.untyped)
  }
  def self.mapNil(value, &blk)
    value.nil? ? nil : blk.call(value)
  end
end


class ::Colour < T::Enum
  extend T::Sig

  enums do
    Red = new("RED")
    Green = new("GREEN")
    Blue = new("BLUE")
  end

  class Attr < EnumAttrBase
    sig { override.params(value: T.untyped).returns(T.nilable(::Colour)) }
    def deserialize(value)
      ::Colour.deserialize(value) unless value.nil?
    end
  end

  sig { returns(String) }
  def to_s
    serialize
  end
end


# T::Structs require forward declarations of reference classes
# dynamically declaring them like this hides the duplicate 
# declaration from sorbet, and keeps ruby happy about 
# classes existing before they're referenced
::Empty = Class.new(T::Struct)
::Simple = Class.new(T::Struct)
::Foo = Class.new(T::Struct)
::Foo::NestedSimple = Class.new(T::Struct)



class ::Empty < T::Struct
  extend T::Sig
  include T::Props::Serializable
  include T::Struct::ActsAsComparable

  sig { returns(String) }
  def to_json
    serialize.to_json
  end

  sig { params(_strict: T::Boolean).returns(T::Hash[String, T.untyped]) }
  def serialize(_strict = true)
    serialize_result = { 
    }
    serialize_result
  end

  sig { params(contents: String).returns(::Empty) }
  def self.decode_json(contents)
    json_obj = JSON.parse(contents)
    from_hash(json_obj)
  end

  sig { params(hash: T::Hash[String, T.untyped]).returns(::Empty) }
  def self.from_hash(hash)
    new(
    )
  end
end


class ::Simple < T::Struct
  extend T::Sig
  include T::Props::Serializable
  include T::Struct::ActsAsComparable

  const :int32_field, T.nilable(Integer)

  sig { returns(String) }
  def to_json
    serialize.to_json
  end

  sig { params(_strict: T::Boolean).returns(T::Hash[String, T.untyped]) }
  def serialize(_strict = true)
    serialize_result = { 
      "int32Field": int32_field,
    }
    serialize_result
  end

  sig { params(contents: String).returns(::Simple) }
  def self.decode_json(contents)
    json_obj = JSON.parse(contents)
    from_hash(json_obj)
  end

  sig { params(hash: T::Hash[String, T.untyped]).returns(::Simple) }
  def self.from_hash(hash)
    new(
      int32_field: PbHelper::mapNil(hash["int32Field"]) { (hash["int32Field"]) },
    )
  end
end


class ::Foo < T::Struct
  extend T::Sig
  include T::Props::Serializable
  include T::Struct::ActsAsComparable

  const :required_simple, ::Simple

  const :maybe_simple, T.nilable(::Simple)

  const :not_required_maybe_simple, T.nilable(::Simple)

  const :required_nested_simple, ::Foo::NestedSimple

  const :maybe_nested_simple, T.nilable(::Foo::NestedSimple)

  const :not_required_maybe_nested_simple, T.nilable(::Foo::NestedSimple)

  const :required_int, Integer

  const :maybe_int, T.nilable(Integer)

  const :not_required_maybe_int, T.nilable(Integer)

  const :required_bool, T::Boolean

  const :maybe_bool, T.nilable(T::Boolean)

  const :required_enum, ::Colour

  const :maybe_enum, T.nilable(::Colour)

  const :maybe_string_relevant_if_required_bool, T.nilable(String)

  const :maybe_string_relevant_if_maybe_bool, T.nilable(String)

  const :required_string_with_custom_validator, String

  const :maybe_string_with_custom_validator, T.nilable(String)

  const :repeated_string_custom_validator, T::Array[String]

  module Oneof; end
  const :oneof, Oneof

  module Oneof
    extend T::Sig
    extend T::Helpers
    include T::Props::Serializable
    sealed!

    sig { params(_strict: T::Boolean).returns(T::Hash[String, T.untyped]) }
    def serialize(_strict = true)
        case self
        when StringField
            { "stringField": value }
        when IntField
            { "intField": value }
          else
            T.absurd(self)
        end
    end

    sig { params(hash: T::Hash[String, T.untyped]).returns(Oneof) }
    def self.from_hash(hash)
      if hash["stringField"] then
        return StringField.new((PbHelper::withDefault(hash["stringField"], "")))
      end
      if hash["intField"] then
        return IntField.new((PbHelper::withDefault(hash["intField"], 0)))
      end
      
      raise "Expected one of, but none were set"
    end

    
    class StringField
      include Oneof
      extend T::Sig

      sig { params(value: String).void }
      def initialize(value)
        @value = T.let(value, String)
      end

      sig { returns(String) }
      def to_s
        value.to_s
      end

      sig { params(other: T.untyped).returns(T::Boolean) }
      def ==(other)
        self.class == other.class &&
          @value == other.value
      end

      sig { returns(String) }
      attr_reader :value
    end
    
    class IntField
      include Oneof
      extend T::Sig

      sig { params(value: Integer).void }
      def initialize(value)
        @value = T.let(value, Integer)
      end

      sig { returns(String) }
      def to_s
        value.to_s
      end

      sig { params(other: T.untyped).returns(T::Boolean) }
      def ==(other)
        self.class == other.class &&
          @value == other.value
      end

      sig { returns(Integer) }
      attr_reader :value
    end
    
  end

  sig { returns(String) }
  def to_json
    serialize.to_json
  end

  sig { params(_strict: T::Boolean).returns(T::Hash[String, T.untyped]) }
  def serialize(_strict = true)
    serialize_result = { 
      "requiredSimple": required_simple.serialize,
      "maybeSimple": maybe_simple&.serialize,
      "notRequiredMaybeSimple": not_required_maybe_simple&.serialize,
      "requiredNestedSimple": required_nested_simple.serialize,
      "maybeNestedSimple": maybe_nested_simple&.serialize,
      "notRequiredMaybeNestedSimple": not_required_maybe_nested_simple&.serialize,
      "requiredInt": required_int,
      "maybeInt": maybe_int,
      "notRequiredMaybeInt": not_required_maybe_int,
      "requiredBool": required_bool,
      "maybeBool": maybe_bool,
      "requiredEnum": required_enum.serialize,
      "maybeEnum": maybe_enum&.serialize,
      "maybeStringRelevantIfRequiredBool": maybe_string_relevant_if_required_bool,
      "maybeStringRelevantIfMaybeBool": maybe_string_relevant_if_maybe_bool,
      "requiredStringWithCustomValidator": required_string_with_custom_validator,
      "maybeStringWithCustomValidator": maybe_string_with_custom_validator,
      "repeatedStringCustomValidator": repeated_string_custom_validator,
    }
    serialize_result = serialize_result.merge(oneof.serialize )
    serialize_result
  end

  sig { params(contents: String).returns(::Foo) }
  def self.decode_json(contents)
    json_obj = JSON.parse(contents)
    from_hash(json_obj)
  end

  sig { params(hash: T::Hash[String, T.untyped]).returns(::Foo) }
  def self.from_hash(hash)
    new(
      required_simple: ::Simple.from_hash(PbHelper::withDefault(hash["requiredSimple"], nil)),
      maybe_simple: PbHelper::mapNil(hash["maybeSimple"]) { ::Simple.from_hash(hash["maybeSimple"]) },
      not_required_maybe_simple: PbHelper::mapNil(hash["notRequiredMaybeSimple"]) { ::Simple.from_hash(hash["notRequiredMaybeSimple"]) },
      required_nested_simple: ::Foo::NestedSimple.from_hash(PbHelper::withDefault(hash["requiredNestedSimple"], nil)),
      maybe_nested_simple: PbHelper::mapNil(hash["maybeNestedSimple"]) { ::Foo::NestedSimple.from_hash(hash["maybeNestedSimple"]) },
      not_required_maybe_nested_simple: PbHelper::mapNil(hash["notRequiredMaybeNestedSimple"]) { ::Foo::NestedSimple.from_hash(hash["notRequiredMaybeNestedSimple"]) },
      required_int: (PbHelper::withDefault(hash["requiredInt"], 0)),
      maybe_int: PbHelper::mapNil(hash["maybeInt"]) { (hash["maybeInt"]) },
      not_required_maybe_int: PbHelper::mapNil(hash["notRequiredMaybeInt"]) { (hash["notRequiredMaybeInt"]) },
      required_bool: (PbHelper::withDefault(hash["requiredBool"], false)),
      maybe_bool: PbHelper::mapNil(hash["maybeBool"]) { (hash["maybeBool"]) },
      required_enum: ::Colour.deserialize(PbHelper::withDefault(hash["requiredEnum"], "RED")),
      maybe_enum: PbHelper::mapNil(hash["maybeEnum"]) { ::Colour.deserialize(hash["maybeEnum"]) },
      maybe_string_relevant_if_required_bool: PbHelper::mapNil(hash["maybeStringRelevantIfRequiredBool"]) { (hash["maybeStringRelevantIfRequiredBool"]) },
      maybe_string_relevant_if_maybe_bool: PbHelper::mapNil(hash["maybeStringRelevantIfMaybeBool"]) { (hash["maybeStringRelevantIfMaybeBool"]) },
      required_string_with_custom_validator: (PbHelper::withDefault(hash["requiredStringWithCustomValidator"], "")),
      maybe_string_with_custom_validator: PbHelper::mapNil(hash["maybeStringWithCustomValidator"]) { (hash["maybeStringWithCustomValidator"]) },
      repeated_string_custom_validator: PbHelper::withDefault(hash["repeatedStringCustomValidator"], []).map{(_1)},
      oneof: Oneof.from_hash(hash),
    )
  end
end


class ::Foo::NestedSimple < T::Struct
  extend T::Sig
  include T::Props::Serializable
  include T::Struct::ActsAsComparable

  const :optional_nested_int, T.nilable(Integer)

  sig { returns(String) }
  def to_json
    serialize.to_json
  end

  sig { params(_strict: T::Boolean).returns(T::Hash[String, T.untyped]) }
  def serialize(_strict = true)
    serialize_result = { 
      "optionalNestedInt": optional_nested_int,
    }
    serialize_result
  end

  sig { params(contents: String).returns(::Foo::NestedSimple) }
  def self.decode_json(contents)
    json_obj = JSON.parse(contents)
    from_hash(json_obj)
  end

  sig { params(hash: T::Hash[String, T.untyped]).returns(::Foo::NestedSimple) }
  def self.from_hash(hash)
    new(
      optional_nested_int: PbHelper::mapNil(hash["optionalNestedInt"]) { (hash["optionalNestedInt"]) },
    )
  end
end

