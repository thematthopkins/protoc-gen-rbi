# typed: strict
# frozen_string_literal: true

# Code generated by protoc-gen-rbi. DO NOT EDIT.

module Validator



    class EmptyValidators
      extend T::Sig
      include Validation
      include 


      include T::Props::Serializable
      include T::Struct::ActsAsComparable
    

      sig {
          returns(T::Array[Validator[::Empty]])
      }
      def self.all_validators
        [
    
        ]
      end
    end



    class SimpleValidators
      extend T::Sig
      include Validation
      include 


      include T::Props::Serializable
      include T::Struct::ActsAsComparable
    
      sig {
        returns ValidatableField[::Simple, T.nilable(String)]
      }
      def self.int32_field
        ValidatableField.new(
          translation: TranslationId.new("<missing translation id>"),
          getter: ->(message) { message.int32_field },
          setter: ->(message, field) { message.int32_field = field },
          validator: Validation::Required.new( TranslationId.new("<missing translation id>"),  ( ->(m) { m.int32_field} ), ([])),
        )
      end
    

      sig {
          returns(T::Array[Validator[::Simple]])
      }
      def self.all_validators
        [
            int32_field.validator,
    
        ]
      end
    end



    class FooValidators
      extend T::Sig
      include Validation
      include 


      include T::Props::Serializable
      include T::Struct::ActsAsComparable
    
      sig {
        returns ValidatableField[::Foo, T.nilable(String)]
      }
      def self.required_simple
        ValidatableField.new(
          translation: TranslationId.new("<missing translation id>"),
          getter: ->(message) { message.required_simple },
          setter: ->(message, field) { message.required_simple = field },
          validator: Validation::AlwaysPresent.new( TranslationId.new("<missing translation id>"),  ( ->(m) { m.required_simple} ), (SimpleValidators.all_validators)),
        )
      end
    
      sig {
        returns ValidatableField[::Foo, T.nilable(String)]
      }
      def self.maybe_simple
        ValidatableField.new(
          translation: TranslationId.new("<missing translation id>"),
          getter: ->(message) { message.maybe_simple },
          setter: ->(message, field) { message.maybe_simple = field },
          validator: Validation::Required.new( TranslationId.new("<missing translation id>"),  ( ->(m) { m.maybe_simple} ), (SimpleValidators.all_validators)),
        )
      end
    
      sig {
        returns ValidatableField[::Foo, T.nilable(String)]
      }
      def self.not_required_maybe_simple
        ValidatableField.new(
          translation: TranslationId.new("<missing translation id>"),
          getter: ->(message) { message.not_required_maybe_simple },
          setter: ->(message, field) { message.not_required_maybe_simple = field },
          validator: Validation::Optional.new( TranslationId.new("<missing translation id>"),  ( ->(m) { m.not_required_maybe_simple} ), (SimpleValidators.all_validators)),
        )
      end
    
      sig {
        returns ValidatableField[::Foo, T.nilable(String)]
      }
      def self.required_nested_simple
        ValidatableField.new(
          translation: TranslationId.new("<missing translation id>"),
          getter: ->(message) { message.required_nested_simple },
          setter: ->(message, field) { message.required_nested_simple = field },
          validator: Validation::AlwaysPresent.new( TranslationId.new("<missing translation id>"),  ( ->(m) { m.required_nested_simple} ), (Foo_NestedSimpleValidators.all_validators)),
        )
      end
    
      sig {
        returns ValidatableField[::Foo, T.nilable(String)]
      }
      def self.maybe_nested_simple
        ValidatableField.new(
          translation: TranslationId.new("<missing translation id>"),
          getter: ->(message) { message.maybe_nested_simple },
          setter: ->(message, field) { message.maybe_nested_simple = field },
          validator: Validation::Required.new( TranslationId.new("<missing translation id>"),  ( ->(m) { m.maybe_nested_simple} ), (Foo_NestedSimpleValidators.all_validators)),
        )
      end
    
      sig {
        returns ValidatableField[::Foo, T.nilable(String)]
      }
      def self.not_required_maybe_nested_simple
        ValidatableField.new(
          translation: TranslationId.new("<missing translation id>"),
          getter: ->(message) { message.not_required_maybe_nested_simple },
          setter: ->(message, field) { message.not_required_maybe_nested_simple = field },
          validator: Validation::Optional.new( TranslationId.new("<missing translation id>"),  ( ->(m) { m.not_required_maybe_nested_simple} ), (Foo_NestedSimpleValidators.all_validators)),
        )
      end
    
      sig {
        returns ValidatableField[::Foo, T.nilable(String)]
      }
      def self.required_int
        ValidatableField.new(
          translation: TranslationId.new("<missing translation id>"),
          getter: ->(message) { message.required_int },
          setter: ->(message, field) { message.required_int = field },
          validator: Validation::AlwaysPresent.new( TranslationId.new("<missing translation id>"),  ( ->(m) { m.required_int} ), ([])),
        )
      end
    
      sig {
        returns ValidatableField[::Foo, T.nilable(String)]
      }
      def self.maybe_int
        ValidatableField.new(
          translation: TranslationId.new("<missing translation id>"),
          getter: ->(message) { message.maybe_int },
          setter: ->(message, field) { message.maybe_int = field },
          validator: Validation::Required.new( TranslationId.new("<missing translation id>"),  ( ->(m) { m.maybe_int} ), ([])),
        )
      end
    
      sig {
        returns ValidatableField[::Foo, T.nilable(String)]
      }
      def self.not_required_maybe_int
        ValidatableField.new(
          translation: TranslationId.new("<missing translation id>"),
          getter: ->(message) { message.not_required_maybe_int },
          setter: ->(message, field) { message.not_required_maybe_int = field },
          validator: Validation::Optional.new( TranslationId.new("<missing translation id>"),  ( ->(m) { m.not_required_maybe_int} ), ([])),
        )
      end
    
      sig {
        returns ValidatableField[::Foo, T.nilable(String)]
      }
      def self.required_bool
        ValidatableField.new(
          translation: TranslationId.new("<missing translation id>"),
          getter: ->(message) { message.required_bool },
          setter: ->(message, field) { message.required_bool = field },
          validator: Validation::AlwaysPresent.new( TranslationId.new("<missing translation id>"),  ( ->(m) { m.required_bool} ), ([])),
        )
      end
    
      sig {
        returns ValidatableField[::Foo, T.nilable(String)]
      }
      def self.maybe_bool
        ValidatableField.new(
          translation: TranslationId.new("<missing translation id>"),
          getter: ->(message) { message.maybe_bool },
          setter: ->(message, field) { message.maybe_bool = field },
          validator: Validation::Required.new( TranslationId.new("<missing translation id>"),  ( ->(m) { m.maybe_bool} ), ([])),
        )
      end
    
      sig {
        returns ValidatableField[::Foo, T.nilable(String)]
      }
      def self.required_enum
        ValidatableField.new(
          translation: TranslationId.new("<missing translation id>"),
          getter: ->(message) { message.required_enum },
          setter: ->(message, field) { message.required_enum = field },
          validator: Validation::AlwaysPresent.new( TranslationId.new("<missing translation id>"),  ( ->(m) { m.required_enum} ), ([])),
        )
      end
    
      sig {
        returns ValidatableField[::Foo, T.nilable(String)]
      }
      def self.maybe_enum
        ValidatableField.new(
          translation: TranslationId.new("<missing translation id>"),
          getter: ->(message) { message.maybe_enum },
          setter: ->(message, field) { message.maybe_enum = field },
          validator: Validation::Required.new( TranslationId.new("<missing translation id>"),  ( ->(m) { m.maybe_enum} ), ([])),
        )
      end
    
      sig {
        returns ValidatableField[::Foo, T.nilable(String)]
      }
      def self.maybe_string_relevant_if
        ValidatableField.new(
          translation: TranslationId.new("<missing translation id>"),
          getter: ->(message) { message.maybe_string_relevant_if },
          setter: ->(message, field) { message.maybe_string_relevant_if = field },
          validator: Validation::RequiredIf.new( TranslationId.new("<missing translation id>"),  ( ->(m) { Validation::Condition::requiredBool(m) } ),  ( ->(m) { m.maybe_string_relevant_if} ), ([])),
        )
      end
    
      sig {
        returns ValidatableField[::Foo, T.nilable(String)]
      }
      def self.required_string_with_custom_validator
        ValidatableField.new(
          translation: TranslationId.new("<missing translation id>"),
          getter: ->(message) { message.required_string_with_custom_validator },
          setter: ->(message, field) { message.required_string_with_custom_validator = field },
          validator: Validation::AlwaysPresent.new( TranslationId.new("<missing translation id>"),  ( ->(m) { m.required_string_with_custom_validator} ), ([ Validation::RequiredStringCustomValidator.new ] + [])),
        )
      end
    
      sig {
        returns ValidatableField[::Foo, T.nilable(String)]
      }
      def self.maybe_string_with_custom_validator
        ValidatableField.new(
          translation: TranslationId.new("<missing translation id>"),
          getter: ->(message) { message.maybe_string_with_custom_validator },
          setter: ->(message, field) { message.maybe_string_with_custom_validator = field },
          validator: Validation::Required.new( TranslationId.new("<missing translation id>"),  ( ->(m) { m.maybe_string_with_custom_validator} ), ([ Validation::RequiredMaybeStringCustomValidator.new ] + [])),
        )
      end
    
      sig {
        returns ValidatableField[::Foo, T.nilable(String)]
      }
      def self.repeated_string_custom_validator
        ValidatableField.new(
          translation: TranslationId.new("<missing translation id>"),
          getter: ->(message) { message.repeated_string_custom_validator },
          setter: ->(message, field) { message.repeated_string_custom_validator = field },
          validator: Validation::RequiredList.new( TranslationId.new("<missing translation id>"),  ( ->(m) { m.repeated_string_custom_validator} ), ([ Validation::RepeatedStringCustomValidator.new ] + [])),
        )
      end
    
      sig {
        returns ValidatableField[::Foo, T.nilable(String)]
      }
      def self.oneof
        ValidatableField.new(
          translation: TranslationId.new("<missing translation id>"),
          getter: ->(message) { message.oneof },
          setter: ->(message, field) { message.oneof = field },
          validator: Validation::AlwaysPresent.new( TranslationId.new("<missing translation id>"),  ( ->(m) { m.oneof} ), ([ Validation::OneofFieldValidator.new ] + [])),
        )
      end
    

      sig {
          returns(T::Array[Validator[::Foo]])
      }
      def self.all_validators
        [
            required_simple.validator,
            maybe_simple.validator,
            not_required_maybe_simple.validator,
            required_nested_simple.validator,
            maybe_nested_simple.validator,
            not_required_maybe_nested_simple.validator,
            required_int.validator,
            maybe_int.validator,
            not_required_maybe_int.validator,
            required_bool.validator,
            maybe_bool.validator,
            required_enum.validator,
            maybe_enum.validator,
            maybe_string_relevant_if.validator,
            required_string_with_custom_validator.validator,
            maybe_string_with_custom_validator.validator,
            repeated_string_custom_validator.validator,
    
            oneof.validator,
        ]
      end
    end



    class Foo::NestedSimpleValidators
      extend T::Sig
      include Validation
      include 


      include T::Props::Serializable
      include T::Struct::ActsAsComparable
    
      sig {
        returns ValidatableField[::Foo::NestedSimple, T.nilable(String)]
      }
      def self.optional_nested_int
        ValidatableField.new(
          translation: TranslationId.new("<missing translation id>"),
          getter: ->(message) { message.optional_nested_int },
          setter: ->(message, field) { message.optional_nested_int = field },
          validator: Validation::Required.new( TranslationId.new("<missing translation id>"),  ( ->(m) { m.optional_nested_int} ), ([])),
        )
      end
    

      sig {
          returns(T::Array[Validator[::Foo::NestedSimple]])
      }
      def self.all_validators
        [
            optional_nested_int.validator,
    
        ]
      end
    end

end
